stages:
  - build
  - test
  - release

build-windows:
  stage: build
  image: stateoftheartio/qt6:6.6-mingw-aqt
  script:
    - set -e
    - sudo apt update
    - sudo apt install -y p7zip-full
    - mkdir -p build-windows
    - qt-cmake . -G Ninja -B ./build-windows
    - cmake --build ./build-windows
    - windeployqt --compiler-runtime --qmldir ./  --dir ./build-windows/MeshViewer/ --libdir ./build-windows/MeshViewer/ --plugindir ./build-windows/MeshViewer/ ./build-windows/MeshViewer.exe
    - cp ./build-windows/MeshViewer.exe ./build-windows/MeshViewer/
    - cd ./build-windows && 7z a ./MeshViewer-Windows.zip ./MeshViewer
  artifacts:
    paths:
      - build-windows/MeshViewer-Windows.zip
    expire_in: 1 week
  only:
    - main

build-linux:
  stage: build
  image: yaya699/meshviewer-qt:linux-6.6.2
  script:
    - set -e
    - mkdir -p build-linux
    - cmake . -B ./build-linux
    - cmake --build ./build-linux
    - cmake --install ${PWD}/build-linux --prefix ${PWD}/build-linux/MeshViewer.AppDir
    - cp ./resources/MeshViewer.desktop ./resources/meshviewer.png ${PWD}/build-linux/MeshViewer.AppDir
    - mkdir ./build-linux/MeshViewer.AppDir/usr
    - cd ./build-linux/MeshViewer.AppDir
    - for dir in bin lib plugins translations; do mv $dir usr/; done
    - ln -s usr/bin/MeshViewer AppRun
    - cd .. && appimagetool --appimage-extract-and-run ./MeshViewer.AppDir ./MeshViewer-linux_x86_64.AppImage
  artifacts:
    paths:
      - build-linux/MeshViewer-linux_x86_64.AppImage
    expire_in: 1 week
  only:
    - main

test-linux:
  stage: test
  image: yaya699/meshviewer-qt:linux-6.6.2
  script:
    - set -e
    - mkdir -p build-tests
    - cmake -B build-tests -S . -DCMAKE_BUILD_TYPE=Debug \
        -DCMAKE_CXX_FLAGS="--coverage -O0 -g" \
        -DCMAKE_EXE_LINKER_FLAGS="--coverage"
    - cmake --build build-tests
    - cd build-tests && ctest --output-on-failure
    - gcovr -r . --xml-pretty -o build-tests/coverage.xml
  artifacts:
    when: always
    paths:
      - build-tests
      - build-tests/Testing
      - build-tests/CMakeFiles/CMakeOutput.log
    reports:
      junit: build-tests/Testing/**/*.xml
      coverage_report:
              coverage_format: cobertura
              path: build-tests/coverage.xml
  only:
    - main

release-github:
  stage: release
  image: alpine:latest
  dependencies:
    - build-windows
    - build-linux
    - test-linux
  script:
    - apk add --no-cache curl jq git

    - export GITHUB_REPO="yanisseF69/MeshViewer"
    - export RELEASE_NAME="Continuous Build"
    - export ZIP_PATH="build-windows/MeshViewer-Windows.zip"
    - export APPIMAGE_PATH="build-linux/MeshViewer-linux_x86_64.AppImage"
    - export TAG_NAME="continuous"

    - |
      echo "Checking for existing release '${TAG_NAME}'..."
      OLD_RELEASE_ID=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" \
        "https://api.github.com/repos/${GITHUB_REPO}/releases/tags/${TAG_NAME}" | jq -r '.id // empty')
      if [ -n "$OLD_RELEASE_ID" ]; then
        echo "Deleting old release ID: ${OLD_RELEASE_ID}"
        curl -s -X DELETE -H "Authorization: token ${GITHUB_TOKEN}" \
          "https://api.github.com/repos/${GITHUB_REPO}/releases/${OLD_RELEASE_ID}"
      else
        echo "No existing release found."
      fi

    - |
      echo "Deleting old tag '${TAG_NAME}' if it exists..."
      TAG_URL="https://api.github.com/repos/${GITHUB_REPO}/git/refs/tags/${TAG_NAME}"
      if curl -s -H "Authorization: token ${GITHUB_TOKEN}" "$TAG_URL" | grep -q "${TAG_NAME}"; then
        curl -s -X DELETE -H "Authorization: token ${GITHUB_TOKEN}" "$TAG_URL"
        echo "Old tag '${TAG_NAME}' deleted."
      else
        echo "No tag '${TAG_NAME}' found."
      fi

    - |
      echo "Recreating tag '${TAG_NAME}'..."
      COMMIT_SHA=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" \
        "https://api.github.com/repos/${GITHUB_REPO}/git/refs/heads/main" | jq -r '.object.sha')

      curl -s -X POST \
        -H "Authorization: token ${GITHUB_TOKEN}" \
        -H "Content-Type: application/json" \
        -d "{\"ref\": \"refs/tags/${TAG_NAME}\", \"sha\": \"${COMMIT_SHA}\"}" \
        "https://api.github.com/repos/${GITHUB_REPO}/git/refs"

    - |
      echo "Creating new release '${RELEASE_NAME}'..."
      RESPONSE=$(curl -s -X POST \
        -H "Authorization: token ${GITHUB_TOKEN}" \
        -H "Content-Type: application/json" \
        -d "{\"tag_name\": \"${TAG_NAME}\", \"name\": \"${RELEASE_NAME}\", \"body\": \"Automated build from GitLab CI.\"}" \
        "https://api.github.com/repos/${GITHUB_REPO}/releases")

      RELEASE_ID=$(echo "$RESPONSE" | jq -r '.id')
      echo "New release created (ID: $RELEASE_ID)"

    - |
      for FILE_PATH in "${ZIP_PATH}" "${APPIMAGE_PATH}"; do
        FILE_NAME=$(basename "${FILE_PATH}")
        echo "Checking for existing asset: ${FILE_NAME}"

        ASSET_ID=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" \
          "https://api.github.com/repos/${GITHUB_REPO}/releases/${RELEASE_ID}/assets" \
          | jq -r ".[] | select(.name==\"${FILE_NAME}\") | .id")

        if [ -n "$ASSET_ID" ] && [ "$ASSET_ID" != "null" ]; then
          echo "Deleting existing asset ID: ${ASSET_ID}"
          curl -s -X DELETE -H "Authorization: token ${GITHUB_TOKEN}" \
            "https://api.github.com/repos/${GITHUB_REPO}/releases/assets/${ASSET_ID}"
        fi
      done

    - |
      echo "Uploading assets..."
      for FILE_PATH in "${ZIP_PATH}" "${APPIMAGE_PATH}"; do
        FILE_NAME=$(basename "${FILE_PATH}")
        if [ -f "${FILE_PATH}" ]; then
          echo "Uploading ${FILE_NAME}..."
          curl -s -X POST \
            -H "Authorization: token ${GITHUB_TOKEN}" \
            -H "Content-Type: application/octet-stream" \
            --data-binary @"${FILE_PATH}" \
            "https://uploads.github.com/repos/${GITHUB_REPO}/releases/${RELEASE_ID}/assets?name=${FILE_NAME}"
        else
          echo "File not found: ${FILE_PATH}"
        fi
      done

  only:
    - main
